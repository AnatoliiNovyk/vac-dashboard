Промпт: Негайний фікс “infinite re-render” після інтеграції графіків (HR only)

Мета

- Зупинити нескінченний ререндер у вкладці HR та відновити стабільні вкладки/таблиці.
- Гарантувати, що графіки рендеряться лише у HR та не викликають повторних перерахунків без причин.

Step 0 — Check \& Plan (без змін коду)

- Відкрий DevTools Performance/Profiler, знайди найчастіше рендерюваний компонент (підозрювані: HRAnalytics.tsx, провайдери даних, таб‑layout).
- Перевір логи: чи немає “Too many re-renders” або повторних state‑сетів у консолі.
- Зафіксуй у changelog першопричину(и).

Step 1 — Заборона setState під час рендеру та у побічних обчисленнях

- Перевір усі компоненти, додані/змінені при інтеграції графіків:
    - HRAnalytics.tsx, data‑hooks, селектори, адаптери даних, провайдери контексту.
- Заборони будь‑який setState під час рендеру:
    - Якщо є обчислення, що викликають setState у тілі компонента — перенеси в useEffect з правильною залежністю або обчислюй через useMemo без setState.
- Уникай ефектів без залежностей, які всередині асинхронно сетять стан щоразу при рендері.
    - Якщо ефект використовує локальні значення — додай точні залежності.
    - Якщо ефект має бути “один раз” — використай порожній масив залежностей, але не чіпай state всередині render.

Step 2 — Виправити залежності useEffect/useMemo/useCallback

- Для кожного useEffect/useMemo/useCallback у HRAnalytics та супутніх хуках:
    - Забезпечити стабільні залежності. Видалити з залежностей нові об’єкти/функції, що створюються на кожен рендер (wrap у useMemo/useCallback).
    - Якщо у залежностях стоїть цілий “filters” об’єкт, який створюється inline, — мемоізувати його або деструктурувати до примітивів.
    - Виключити “today = new Date()” з залежностей (винести в useMemo(() => startOfToday(), []) або передавати як константу зі сторони батьківського компонента).

Step 3 — Стабілізувати пропси графіків

- Не передавати в графіки:
    - анонімні функції, створені inline — обгорнути в useCallback з потрібними залежностями;
    - нові масиви/об’єкти з map/filter кожен рендер — мемоізувати через useMemo;
    - Date/Math.random() — замінити на стабільні значення/мемо.
- Якщо бібліотека графіків перерисовує полотно при зміні reference даних — подавати immutable, але мемоізовані серії.

Step 4 — Data fetching та контекст

- Заборонити fetch/dispatch у рендері. Перевірити, що ефекти з fetch мають залежність лише від фільтрів і не створюють їх на льоту.
- Якщо застосовано контекст із value={{...}} прямо в рендері — мемоізувати value через useMemo, інакше спровокує ререндер усіх дітей.

Step 5 — Guard для HR only + ErrorBoundary

- Рендер HRAnalytics тільки коли activeTab === 'HR'.
- Обгорнути HRAnalytics у локальний ErrorBoundary, щоб падіння графіків не переробляло всю вкладку.

Step 6 — DIFF (зразки виправлень)

- Заборона інлайн‑дат та функцій у залежностях:

// Погано
const today = new Date();
useEffect(() => { setState(calc(today)); }, [filters, today]);

// Добре
const today = useMemo(() => new Date(), []); // або startOfToday()
useEffect(() => { setState(calc(today)); }, [filters, today]);

// Погано
const onPointClick = (p) => setFilters({ ...filters, day: p.x });

// Добре
const onPointClick = useCallback((p) => {
setFilters((prev) => ({ ...prev, day: p.x }));
}, []);

// Погано
const series = data.map(/* … */);

// Добре
const series = useMemo(() => data.map(/* … */), [data]);

- Заборона setState у тілі компонента:

// Погано
if (!ready) setReady(true);

// Добре
useEffect(() => { setReady(true); }, []);

- Стабілізація context value:

// Погано
<FiltersContext.Provider value={{ filters, setFilters }}>
// Добре
const providerValue = useMemo(() => ({ filters, setFilters }), [filters, setFilters]);
<FiltersContext.Provider value={providerValue}>

Step 7 — Перевірка

- Відкрити HR вкладку, увімкнути React Profiler: підтвердити, що дерево рендериться одноразово на зміну фільтра, а не безкінечно.
- Перевірити Manager/My View: графіків немає, вкладки/таблиці стабільні.
- Додати changelog із переліком точок, де були цикли, і конкретними DIFF.

Step 8 — Запобігання регресіям

- ESLint rule: react-hooks/exhaustive-deps (налаштовано коректно, але не сліпо додавати нестабільні залежності).
- Заборонити використання нових об’єктів у залежностях без мемоізації.
- Додати простий тест/health check: monitor повторних renders count у dev (guard log/once).

Очікуваний результат

- Нескінченний ререндер припиняється.
- Вкладки й таблиці залишаються стабільними.
- Графіки відмальовуються лише при реальній зміні фільтрів/даних і тільки у вкладці HR.
- Жодних згадок “заявок/затверджень”.
